# 시간복잡도

### • 시간복잡도

\- 주어진 문제를 해결하기 위한 연산횟수를 의미한다.<br>
\- 일반적으로 1억번의 연산을 했을 때 1초의 시간이 걸린다고 간주한다.<br>
ex) 시간제한 2초 → 2억번 미만의 연산내에 문제를 해결해야 한다.<br><br>

### • 시간복잡도 유형

\- <b>빅-오메가</b>: 최선일 때(best case)의 연산 횟수를 나타낸 표기법<br>
\- <b>빅-세타</b>: 보통일 때(average case)의 연산 횟수를 나타낸 표기법<br>
\- <b>빅-오</b>: 최악일 때(worst case)의 연산 횟수를 나타낸 표기법<br>

> 코딩테스트를 진행해야할 때 택해야할 표기법은 '빅-오 표기법'이다.<br>
> 실제로 코딩테스트는 단순한 문제가 나오지 않을 뿐만 아니라 여러개의 test case가 존재하기 떄문에 항상 최악의 경우를 염두하고 코딩테스트를 임해야하기 때문이다.<br>
<br>

### • 연산횟수 계산법
> 연산횟수 = 알고리즘 시간 복잡도 x 데이터의 크기<br>
<br>

### • 시간복잡도 활용
\- 시간복잡도를 활용하게 되면 문제에서 사용할 수 있는 알고리즘을 선택할 수 있기때문에 문제를 해결하는데 용이하다.<br>
\- 데이터의 크기(N)을 단서로 알고리즘을 추측해 볼 수 있다.<br>

> 시간복잡도 활용 예시<br>
> 1. 문제에 주어진 시간이 2초라는 것을 확인하고 연산 횟수 2억번 안에 답을 구해야한다는 것을 파악한다.<br>
> 2. 만약 정렬을 이용해 문제를 해결해야할 경우 내가 사용하려는 정렬이 연산횟수 2억번 미만안에 답이 나오는지 연산횟수를 계산해 파악하고 만약 2억번이 넘어간다면 다른 정렬방식을 사용해 문제를 해결할 수 있도록 한다.<br>
<br>

### • 시간복잡도 도출 기준

\- 상수는 시간복잡도 계산에서 제외한다.<br>
ex) O(N)이나 O(3N)은 코드에서 실질적으로 큰 영향도가 없기 때문에 상수를 제거해 두코드 모두 O(N)으로 표현할 수 있다.<br>
\- 가장 많이 중첩된 반복무느이 수행횟수가 시간 복잡도의 기준이 된다.<br>
ex) O(N^2) 식에서 일반적인 for문이 여러개 있다고 하더라도 이중for문이 시간복잡도를 더 크리티컬하게 만들기 때문에 N^2으로 복잡도가 유지된다.<br><br>

### • 시간복잡도 도출 기준

1. 알맞은 알고리즘 선택하는데 기준이 된다.<br>
2. 비효율적인 로직을 찾아서 효율적으로 바꿀 수 있다.<br>
